package net.mind_engine.oculus.testrunframework.test;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.regex.Matcher;

import net.mind_engine.oculus.testrunframework.ClassUtils;
import net.mind_engine.oculus.testrunframework.Config;
import net.mind_engine.oculus.testrunframework.TestRunListener;
import net.mind_engine.oculus.testrunframework.annotations.Action;
import net.mind_engine.oculus.testrunframework.annotations.Component;
import net.mind_engine.oculus.testrunframework.annotations.ErrorHandler;
import net.mind_engine.oculus.testrunframework.annotations.InputParameter;
import net.mind_engine.oculus.testrunframework.annotations.RollbackHandler;
import net.mind_engine.oculus.testrunframework.annotations.Temp;
import net.mind_engine.oculus.testrunframework.events.ActionEvent;
import net.mind_engine.oculus.testrunframework.events.Event;
import net.mind_engine.oculus.testrunframework.exception.NoSuchActionException;
import net.mind_engine.oculus.testrunframework.exception.NoSuchErrorHandler;
import net.mind_engine.oculus.testrunframework.suite.Suite;

public class TestRunner {
	protected TestDescriptor testDescriptor;
	protected TestRunner parent;
	protected TestSession testSession;
	protected Object test;
	private TestRunListener testRunListener;
	private int actionsNumber = 0;

	private Stack<Method> rollbackStack;
	private boolean destroyTestSessionOnFinish = true;

	/**
	 * List of tests which should be run within the current test runner and use
	 * its test session as root session
	 */
	private List<TestDefinition> includeTests;

	public TestRunner() {

	}

	protected TestRunner(TestRunner parent) {
		this.parent = parent;
	}

	/**
	 * Runs specified test and injects the specified parameters into the test
	 * 
	 * @param testClass
	 *            Class of the test
	 * @param parameters
	 *            Pair of parameter name and parameter value which should be
	 *            injected in the test
	 * @throws Throwable
	 */
	public static void runTest(Class<?> testClass, String... parameters) throws Throwable {
		TestDefinition td = new TestDefinition();
		td.setMapping("classpath:" + testClass.getName());

		if (parameters != null) {
			td.setParameters(new HashMap<String, TestParameter>());
			for (int i = 0; i < parameters.length; i += 2) {
				TestParameter parameter = new TestParameter();
				parameter.setName(parameters[i]);
				parameter.setValue(parameters[i]);
				td.getParameters().put(parameter.getName(), parameter);
			}
		}

		TestRunner.runTest(td, null, null);
	}

	/**
	 * This method is used in test. <br>
	 * It runs the child tests and attaches the child test session to existing
	 * session. <br>
	 * 
	 * @param parentTest
	 * @param testDescriptor
	 * @throws Throwable
	 */
	public static void runTest(TestDefinition testDefinition) {
		TestRunner.runTest(testDefinition, null, null);
	}

	/**
	 * Injects the test to the parent test runners test and runs it
	 * 
	 * @param testDefinition
	 *            definition of the test
	 * @param parent
	 *            Instance of test runner where this test should be injected
	 */
	public static void runTestInjected(TestDefinition testDefinition, TestRunner parent) {
		TestRunner.runTest(testDefinition, null, parent);
	}

	public static void runTest(Class<?> testClass) {
		TestDefinition td = new TestDefinition();
		td.setMapping("classpath:" + testClass.getName());
		TestRunner.runTest(td, null, null);
	}

	/**
	 * This method is used in test. <br>
	 * It runs the child tests and attaches the child test session to existing
	 * session. <br>
	 * 
	 * @param parentTest
	 * @param testDescriptor
	 * @throws Throwable
	 */
	public static void runTest(TestDefinition testDefinition, TestRunListener testRunListener, TestRunner parentTestRunner) {
		TestRunner testRunner = new TestRunner();
		testRunner.setParent(parentTestRunner);
		testRunner.setTestRunListener(testRunListener);
		testRunner.setTestDescriptor(new TestDescriptor(testDefinition));
		try {
			testRunner.runTest();
		}
		catch (Throwable e) {
			throw new RuntimeException(e);
		}
	}

	public void instantiateTestInputParameters(Suite suite){
		System.out.println("Instantiating all input parameters");
		for (Map.Entry<String, Field> inputParameter : testDescriptor.getInputParameters().entrySet()) {
			System.out.print(inputParameter.getKey() + ": ");
			Field field = inputParameter.getValue();
			Object value = null;
			/*
			 * Searching for parameter dependency. If it exists then the
			 * parameter will be instantiated with this dependency
			 */
			TestDependency dependency = testDescriptor.getDependency(inputParameter.getKey());
			if (dependency != null && suite != null) {
				/*
				 * Fetching parameter value from prerequisite test output
				 * parameter in the same suite
				 */
				TestDefinition prerequisiteTestDefinition = suite.getTestsMap().get(dependency.getPrerequisiteTestId());
				if (prerequisiteTestDefinition == null)
					throw new NullPointerException("The test with id = " + dependency.getPrerequisiteTestId() + " doesn't exist in suite");

				Object dependentValue = null;
				boolean bParameterFound = false;
				if (suite.getTestsOutputParameters().containsKey(dependency.getPrerequisiteTestId())) {
					Map<String, Object> testParameters = suite.getTestsOutputParameters().get(dependency.getPrerequisiteTestId());
					if (testParameters.containsKey(dependency.getPrerequisiteParameterName())) {
						dependentValue = testParameters.get(dependency.getPrerequisiteParameterName());
						bParameterFound = true;
					}
				}
				if (!bParameterFound) {
					if (suite.getTestsInputParameters().containsKey(getTestId())) {
						Map<String, Object> testParameters = suite.getTestsInputParameters().get(getTestId());
						if (testParameters.containsKey(dependency.getPrerequisiteParameterName())) {
							dependentValue = testParameters.get(dependency.getPrerequisiteParameterName());
						}
					}
				}
				value = dependentValue;
				testDescriptor.setTestInputParameter(field, value);
				System.out.println("setting from test dependency");
			}
			else {
				/*
				 * Fetching test parameter from test definition
				 */
				TestParameter testParameter = testDescriptor.getTestDefinition().getParameters().get(inputParameter.getKey());
				if (testParameter != null) {
					value = testDescriptor.instantiateInputParameter(field, testParameter.getValue());
					System.out.println("setting from test definition");
				}
				else {
					/*
					 * Searching for a default value for a parameter if it
					 * wasn't set in test run
					 */
					InputParameter inputParameterAnnotation = field.getAnnotation(InputParameter.class);
					value = testDescriptor.instantiateInputParameter(field, inputParameterAnnotation.defaultValue());
					System.out.println("using default value");
				}
			}
			/*
			 * Putting test input parameter value to suite input parameters
			 * storage
			 */
			if (suite != null) {
				if (!suite.getTestsInputParameters().containsKey(getTestId())) {
					suite.getTestsInputParameters().put(getTestId(), new HashMap<String, Object>());
				}
				suite.getTestsInputParameters().get(getTestId()).put(inputParameter.getKey(), value);
			}
		}
	}
	
	@SuppressWarnings("unchecked")
    public ComponentProvider createComponentProvider(){
		Config config = Config.getInstance();
		
		String componentProviderClassName = config.get(Config.COMPONENT_PROVIDER);
		if(componentProviderClassName==null || componentProviderClassName.isEmpty()){
			throw new IllegalArgumentException(Config.COMPONENT_PROVIDER+" should not be empty, check your configuration");
		}
		try{
			Class<? extends ComponentProvider> clazz = (Class<? extends ComponentProvider>) Class.forName(componentProviderClassName);
			return clazz.getConstructor().newInstance();
		}
		catch (Exception e) {
			throw new IllegalArgumentException(Config.COMPONENT_PROVIDER+" could not be instantiated with \""+componentProviderClassName+"\" classpath", e);
		}
	}
	
	/**
	 * Instantiating test components using {@link ComponentProvider} customized by user
	 * @throws InvocationTargetException 
	 * @throws IllegalAccessException 
	 * @throws IllegalArgumentException 
	 */
	public void instantiateTestComponents(){
		ComponentProvider componentProvider = createComponentProvider();
		for (Map.Entry<String, Field> componentParameter : testDescriptor.getComponentParameters().entrySet()) {
			Component component = componentParameter.getValue().getAnnotation(Component.class);
			Object componentObject = componentProvider.provideComponent(component, componentParameter.getValue().getType());
			/*
			 * checking if component field has getter method
			 */
			try{
				if(testDescriptor.getComponentParametersSetterMethods().containsKey(componentParameter.getKey())){
					testDescriptor.getComponentParametersSetterMethods().get(componentParameter.getKey()).invoke(test, componentObject);
				}
				else{
					componentParameter.getValue().set(test, componentObject);
				}
			}
			catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}
	
	public void runTest() {
		TestInformation testInformation = new TestInformation();
		testInformation.setTestDescriptor(testDescriptor);

		Suite suite = testDescriptor.getTestDefinition().getSuite();

		rollbackStack = new Stack<Method>();

		if (!testDescriptor.isInformationCollected()) {
			testDescriptor.collectTestInformation();

		}
		if (testRunListener != null) {
			try {
				testRunListener.onTestStarted(testInformation);
			}
			catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		
		/*
		 * Instantiating test. Setting the test instance to the "test" field of
		 * TestRunner. It will be used if we need to run another test in a
		 * session of already existing test
		 */
		test = testDescriptor.createTestInstance();
		
		/*
		 * Creating TestSession instance from now it can be obtained in test and
		 * will live only until the test is completed. Checking for a parent
		 * testRunner as if it is able when we need to ad attach new test
		 * session to its session
		 */
		if (testSession == null) {
			testSession = TestSession.create(this);
			// Looking for parent testRunner
			if (testSession.getParent() != null) {
				parent = testSession.getParent().testRunner;
			}
			else
				parent = null;
		}
		

		/*
		 * Instantiating all test input parameters
		 */
		instantiateTestInputParameters(suite);

		/*
		 * Instantiating all test components as POJO objects
		 */
		if(testDescriptor.getComponentParameters().size()>0){
			instantiateTestComponents();
		}

		try {

			/*
			 * Running an entry action method
			 */
			if (testDescriptor.getEntryActionMethod() == null)
				throw new IllegalArgumentException("There is no entry action defined within a test");
			if (testDescriptor.getActionMethods().size() == 0)
				throw new IllegalArgumentException("There are no actions defined within a test");
			try {
				runAction(testDescriptor.getEntryActionMethod(), testInformation);
			}
			catch (Throwable e) {
				throw new RuntimeException(e);
			}

			/*
			 * Collecting the output parameters
			 */
			if (suite != null) {
				suite.getTestsOutputParameters().put(testDescriptor.getTestDefinition().getCustomId(), testDescriptor.collectOutputParameterValues());
				testDescriptor.setFinished(true);
			}

			/*
			 * Running the included tests
			 */
			if (includeTests != null) {
				for (TestDefinition test : includeTests) {
					TestRunner.runTestInjected(test, this);
				}
			}
		}
		finally {
			/*
			 * Invoking all rollback handlers which were collected during the
			 * actions running
			 */
			while (!rollbackStack.isEmpty()) {
				Method rollbackMethod = rollbackStack.pop();

				/*
				 * Calling the before rollback subscriber if such exist
				 */
				if (testDescriptor.getBeforeRollbackMethod() != null) {
					try {
						RollbackInformation rollbackInformation = new RollbackInformation();
						rollbackInformation.setMethod(rollbackMethod);
						RollbackHandler annotation = rollbackMethod.getAnnotation(RollbackHandler.class);
						if (annotation != null) {
							rollbackInformation.setName(annotation.name());
						}
						else
							rollbackInformation.setName("Undefined Rollback Handler");
						Method before = testDescriptor.getBeforeRollbackMethod();
						before.invoke(testDescriptor.getTestInstance(), rollbackInformation);
					}
					catch (Throwable ex) {
						ex.printStackTrace();
					}
				}
				/*
				 * Calling the rollback handlers method
				 */
				try {
					rollbackMethod.invoke(testDescriptor.getTestInstance());
				}
				catch (InvocationTargetException e) {
					if (testDescriptor.getOnTestFailureMethod() != null) {
						try {
							testDescriptor.getOnTestFailureMethod().invoke(testDescriptor.getTestInstance(), e.getTargetException());
						}
						catch (Exception e2) {
							e2.printStackTrace();
						}
					}
				}
				catch (Throwable e) {
					e.printStackTrace();
				}
				/*
				 * Calling the after rollback subscriber if such exist
				 */
				if (testDescriptor.getAfterRollbackMethod() != null) {
					try {
						RollbackInformation rollbackInformation = new RollbackInformation();
						RollbackHandler annotation = rollbackMethod.getAnnotation(RollbackHandler.class);
						if (annotation != null) {
							rollbackInformation.setName(annotation.name());
						}
						else
							rollbackInformation.setName("Undefined Rollback Handler");
						Method after = testDescriptor.getAfterRollbackMethod();
						after.invoke(testDescriptor.getTestInstance(), rollbackInformation);
					}
					catch (Throwable ex) {
						ex.printStackTrace();
					}
				}
			}

			if (testDescriptor.getAfterTestMethod() != null) {
				try {
					testDescriptor.getAfterTestMethod().invoke(testDescriptor.getTestInstance(), testInformation);
				}
				catch (Exception e) {
					throw new RuntimeException(e);
				}
			}

			if (testRunListener != null) {
				try {
					testRunListener.onTestFinished(testInformation);
				}
				catch (Exception e) {
					e.printStackTrace();
				}
			}
			/*
			 * Destroying the test session
			 */
			if (destroyTestSessionOnFinish) {
				TestSession.destroy(testSession);
			}
			clearTestData();
			testSession = null;
		}
	}

	/**
	 * This method is used in the end of test. It sets null values to all fields
	 * marked with {@link Temp} annotation of the tests class. This operation is
	 * needed to prevent java heap spaces which could occur while running a
	 * suite with big amount of tests in it.
	 * 
	 * @throws IllegalAccessException
	 * @throws IllegalArgumentException
	 */
	public void clearTestData() {
		Class<?> testClass = testDescriptor.getTestDefinition().getTestClass();
		Field[] fields = testClass.getDeclaredFields();
		for (Field field : fields) {
			/*
			 * Removing all fields which were marked as temporary.
			 */
			if (field.getAnnotation(Temp.class) != null) {
				if (!ClassUtils.isFieldPrimitive(field)) {
					if (Modifier.isPublic(field.getModifiers()) && !Modifier.isFinal(field.getModifiers())) {
						try {
							field.set(testDescriptor.getTestInstance(), null);
						}
						catch (Exception e) {
							e.printStackTrace();
						}
					}
					else {
						try {
							Method setterMethod = ClassUtils.getSetterMethod(field);
							setterMethod.invoke(testDescriptor.getTestInstance(), new Object[] { null });
						}
						catch (Exception e) {

						}
					}
				}
			}
		}

		/*
		 * Clearing all not needed fields in TestDescriptor
		 */
		testDescriptor.clearUnusedData();
	}

	public Long getTestId() {
		return testDescriptor.getTestDefinition().getTestId();
	}

	public Suite getSuite() {
		return testDescriptor.getTestDefinition().getSuite();
	}

	/**
	 * Recursive method which invokes all the test actions in the test action
	 * sequence by the "next" parameter of Action
	 * 
	 * @param method
	 * @throws Throwable
	 */
	public void runAction(Method method, TestInformation testInformation) throws Throwable {
		Boolean bInterruptTest = false;

		Action actionAnnotation = null;
		String nextActionName = null;
		String rollbackHandlerName = null;
		try {
			if (method == null)
				throw new RuntimeException("The action is not specified");

			actionAnnotation = method.getAnnotation(Action.class);
			nextActionName = actionAnnotation.next();
			rollbackHandlerName = actionAnnotation.rollback();

			if (testDescriptor.getEntryActionMethod() == method) {
				/*
				 * Calling the before test event handler of test
				 */
				if (testDescriptor.getBeforeTestMethod() != null) {
					testDescriptor.getBeforeTestMethod().invoke(testDescriptor.getTestInstance(), testInformation);
				}
			}

			ActionInformation actionInformation = new ActionInformation();
			actionInformation.setActionMethod(method);
			actionInformation.setActionName(actionAnnotation.name());
			actionInformation.setClassName(testDescriptor.getTestInstance().getClass().getName());

			if (testRunListener != null) {
				try {
					// Calculating the percent of completed test actions
					int allActionsAmount = testDescriptor.getActionMethods().size();
					if (actionsNumber < testDescriptor.getActionMethods().size()) {
						actionsNumber++;
					}
					float p = 100 * actionsNumber / allActionsAmount;
					actionInformation.setPercent(Math.round(p));
					testRunListener.onTestAction(actionInformation);
				}
				catch (Exception e) {
					e.printStackTrace();
				}
			}

			if (testDescriptor.getBeforeActionMethod() != null) {
				testDescriptor.getBeforeActionMethod().invoke(testDescriptor.getTestInstance(), actionInformation);
			}

			/*
			 * Invoking the action events
			 */
			ActionEvent actionEvent = new ActionEvent();
			actionEvent.setActionInformation(actionInformation);
			actionEvent.setBefore(true);
			notifyEvent(actionEvent);

			/*
			 * Invoking action
			 */
			method.invoke(testDescriptor.getTestInstance());

			/*
			 * Invoking the action events
			 */
			actionEvent.setBefore(false);
			notifyEvent(actionEvent);

			if (testDescriptor.getAfterActionMethod() != null) {
				testDescriptor.getAfterActionMethod().invoke(testDescriptor.getTestInstance(), actionInformation);
			}
		}
		catch (InvocationTargetException e) {
			Throwable targetException = e.getTargetException();
			/*
			 * Test has failed with an exception. Seeking for test failure
			 * subscriber Seeking for the error handler
			 */
			String onErrorHandlerName = actionAnnotation.onerror();
			boolean bThrowError = true;
			if (onErrorHandlerName != null && !onErrorHandlerName.isEmpty()) {
				bThrowError = false;
				Throwable throwable = runErrorHandler(onErrorHandlerName, e.getTargetException());
				if (throwable != null) {
					targetException = throwable;
					bThrowError = true;
				}
			}
			else {
				/*
				 * Trying to fetch MainErrorHandler for this specific exception.
				 * If there will be no handler found - then the exception will be thrown higher
				 */
				try{
					if(invokeMainErrorHandlerMethod(targetException)){
						bInterruptTest = true;
						bThrowError = true;
					}
				}
				catch (Exception mehException) {
					targetException = mehException;
					bInterruptTest = true;
					bThrowError = true;
				}
			}
			// Seeking for the OnTestFailure method handler
			if (bThrowError && testDescriptor.getOnTestFailureMethod() != null) {
				try {
					testDescriptor.getOnTestFailureMethod().invoke(testDescriptor.getTestInstance(), targetException);
				}
				catch (Exception e2) {
					e2.printStackTrace();
				}
			}
			if (bThrowError)
				throw targetException;
		}

		if (rollbackHandlerName != null && !rollbackHandlerName.isEmpty()) {
			Method rollbackMethod = testDescriptor.getRollbackMethods().get(method.getName());
			rollbackStack.push(rollbackMethod);
		}

		if (!bInterruptTest && (nextActionName != null && !nextActionName.isEmpty())) {
			Method nextMethod = testDescriptor.getActionMethods().get(nextActionName);
			if (nextMethod == null)
				throw new NoSuchActionException(nextActionName);
			runAction(nextMethod, testInformation);
		}
	}

	/**
	 * Passes the occurred exception to the exception handler
	 * 
	 * @param exception
	 * @return true if there is a handler for specified exception
	 * @throws InvocationTargetException
	 * @throws IllegalAccessException
	 * @throws IllegalArgumentException
	 */
	public boolean invokeMainErrorHandlerMethod(Throwable exception) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
		Method method = testDescriptor.getMainExceptionHadlerMethods().get(exception.getClass());
		if (method != null) {
			method.invoke(testDescriptor.getTestInstance(), exception);
			return true;
		}
		return false;
	}

	/**
	 * Recursive method which invokes all the error handlers in a sequence.<br>
	 * Uses the "next" annotation parameter of error handler and invokes next
	 * error handler method
	 * 
	 * @param onErrorHandlerName
	 * @param exception
	 * @throws Throwable
	 */
	@SuppressWarnings("unused")
	public Throwable runErrorHandler(String onErrorHandlerName, Throwable exception) throws Throwable {
		Method method = testDescriptor.getErrorHandlerMethods().get(onErrorHandlerName);
		ErrorHandler errorHandlerAnnotation = method.getAnnotation(ErrorHandler.class);

		if (method == null)
			throw new NoSuchErrorHandler(onErrorHandlerName);

		ErrorInformation errorInformation = new ErrorInformation();
		errorInformation.setException(exception);
		errorInformation.setName(errorHandlerAnnotation.name());
		errorInformation.setMethod(method);
		if (testDescriptor.getBeforeErrorHandlerMethod() != null) {
			testDescriptor.getBeforeErrorHandlerMethod().invoke(testDescriptor.getTestInstance(), errorInformation);
		}

		// Invoking the error handler method
		Throwable throwable = null;
		try {
			method.invoke(testDescriptor.getTestInstance(), exception);
		}
		catch (InvocationTargetException e) {
			throwable = e.getTargetException();
		}

		if (testDescriptor.getAfterErrorHandlerMethod() != null) {
			testDescriptor.getAfterErrorHandlerMethod().invoke(testDescriptor.getTestInstance(), errorInformation);
		}

		if (errorHandlerAnnotation.next() != null && !errorHandlerAnnotation.next().isEmpty()) {
			runErrorHandler(errorHandlerAnnotation.next(), exception);
		}
		return throwable;
	}

	public void notifyEvent(Event event) throws Exception {
		if (event instanceof ActionEvent) {
			ActionEvent actionEvent = (ActionEvent) event;
			if (actionEvent.isBefore()) {
				runActionEvent(testDescriptor.getBeforeEventDescriptors(), actionEvent);
			}
			else {
				runActionEvent(testDescriptor.getAfterEventDescriptors(), actionEvent);
			}
		}

		if (parent != null) {
			parent.notifyEvent(event);
		}
	}

	/**
	 * Checks if action name or action path match the predefined regular
	 * expression and run the event method
	 * 
	 * @param eventDescriptors
	 * @param actionInformation
	 * @throws Exception
	 */
	public void runActionEvent(List<EventDescriptor> eventDescriptors, ActionEvent actionEvent) throws Exception {
		ActionInformation actionInformation = actionEvent.getActionInformation();
		for (EventDescriptor eventDescriptor : eventDescriptors) {
			Matcher matcher = eventDescriptor.getActionPattern().matcher(actionInformation.getActionMethod().getName());
			boolean bMatches = false;
			if (matcher.matches()) {
				bMatches = true;
			}
			else {
				String actionPath = actionInformation.getActionPath();
				matcher = eventDescriptor.getActionPattern().matcher(actionPath);
				if (matcher.matches()) {
					bMatches = true;
				}
			}
			if (bMatches) {
				/*
				 * Invoking the action event method
				 */
				eventDescriptor.getMethod().invoke(testDescriptor.getTestInstance(), actionEvent);
			}
		}
	}

	public void setTestDescriptor(TestDescriptor testDescriptor) {
		this.testDescriptor = testDescriptor;
	}

	public Object getTestInstance() {
		return test;
	}

	public void setParent(TestRunner parent) {
		this.parent = parent;
	}

	public TestRunner getParent() {
		return parent;
	}

	@Override
	public String toString() {
		return "{test=" + test + "}";
	}

	public void setTestRunListener(TestRunListener testRunListener) {
		this.testRunListener = testRunListener;
	}

	public TestRunListener getTestRunListener() {
		return testRunListener;
	}

	public void setDestroyTestSessionOnFinish(boolean destroyTestSessionOnFinish) {
		this.destroyTestSessionOnFinish = destroyTestSessionOnFinish;
	}

	public boolean isDestroyTestSessionOnFinish() {
		return destroyTestSessionOnFinish;
	}

	public TestSession getTestSession() {
		return testSession;
	}

	public void setTestSession(TestSession testSession) {
		this.testSession = testSession;
	}

	public TestDescriptor getTestDescriptor() {
		return testDescriptor;
	}

	public void setTest(Object test) {
		this.test = test;
	}

	public void setIncludeTests(List<TestDefinition> includeTests) {
		this.includeTests = includeTests;
	}

	public List<TestDefinition> getIncludeTests() {
		return includeTests;
	}
}
